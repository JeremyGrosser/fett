#!/usr/bin/env python
# Fett
# A tool for building jails with clone(2) and overlayfs
#
# Copyright 2013 Uber Technologies, Inc.
# MIT License

import collections
import subprocess
import argparse
import logging
import os.path
import os
import random
import time
import sys

import fett


logging.basicConfig(
        format='%(asctime)s %(name)s %(levelname)s %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S')
log = logging.getLogger('fett')


class Layer(object):
    def __init__(self, rootdir, name):
        self.rootdir = rootdir
        self.name = name

    @property
    def path(self):
        path = os.path.join(self.rootdir, self.name)
        assert path.startswith(self.rootdir)
        return path

    def exists(self):
        return os.path.exists(self.path)
    
    def read_metadata(self):
        try:
            with open(os.path.join(self.path, '.fettinfo'), 'r') as fd:
                meta = [x.rstrip('\n').split('=', 1) for x in fd.readlines() if not x.startswith('#')]
                meta = dict(meta)
                return meta
        except IOError as e:
            return None

    def write_metadata(self, meta):
        with open(os.path.join(self.path, '.fettinfo'), 'w') as fd:
            for key, value in meta.iteritems():
                fd.write('%s=%s\n' % (key, value))
            fd.flush()
            fd.close()

    def is_root_layer(self):
        meta = self.read_metadata()
        if meta is None:
            return True
        else:
            return False

    @property
    def parent(self):
        meta = self.read_metadata()
        if meta:
            parent = meta['parent_layer_name']
            return Layer(self.rootdir, parent)
        else:
            return None
    
    def create(self, parent_layer=None):
        '''
        Create an empty directory for this layer and write out a metadata (.fettinfo) file
        '''
        try:
            os.makedirs(self.path)
        except os.error as e:
            log.critical('Unable to create layer directory %s: %s' % (self.path, str(e)))
            return -1

        if parent_layer is not None:
            self.write_metadata({
                'parent_layer_name': parent_layer.name,
            })
        return 0

    def destroy(self):
        '''
        Nuke it from orbit
        '''
        return subprocess.call('rm -rf %s' % self.path, shell=True)

    def mount(self):
        '''
        Recursively mount overlayfs until we find a root layer
        '''
        if self.is_root_layer():
            # don't mount non-overlay layers, just use them directly as read-only lowerdir
            return self.path
        
        mountpoint = os.path.join(self.rootdir, '.mounts', self.name)
        log.debug('Mount layer %s at %s' % (self.path, mountpoint))
        if ensure_directory(mountpoint) != 0:
            return None

        if not self.parent.exists():
            log.critical('Parent layer of %s, %s does not exist' % (self.name, parent.name))
            return None

        parent_mountpoint = self.parent.mount()
        if parent_mountpoint is None:
            return None

        if os.path.ismount(mountpoint):
            log.critical('%s is already mounted' % mountpoint)
            return None

        ret = subprocess.call('mount -t overlayfs -o rw,lowerdir=%s,upperdir=%s none %s' % 
                (parent_mountpoint, self.path, mountpoint), shell=True)
        if ret != 0:
            log.error('Unable to mount %s' % mountpoint)
            return None
        return mountpoint

    
    def unmount(self):
        '''
        Recursively unmount overlayfs until we find a root layer
        '''
        if self.is_root_layer():
            return 0
        
        mountpoint = os.path.join(self.rootdir, '.mounts', self.name)
        try:
            log.debug('umount %s' % mountpoint)
            fett.umount(mountpoint)
        except os.error as e:
            log.critical('Unable to unmount %s' % mountpoint)
            return -1

        try:
            os.rmdir(mountpoint)
        except os.error as e:
            log.error('Unable to delete overlay mount point %s: %s' % (mountpoint, str(e)))
            return -1

        if self.parent is not None:
            return self.parent.unmount()
        else:
            return 0


class Fett(object):
    def __init__(self):
        self.rootdir = os.environ.get('FETT_ROOT', None) or '/var/lib/fett'

    def main(self):
        '''
        Entry point for the fett CLI. Uses argparse to implement subcommands
        and options parsing, then delegates control to cmd_ methods to
        perform the logic behind each command.
        '''
        parser = argparse.ArgumentParser()
        parser.add_argument('--debug', '-d', action='store_true')
        parser.add_argument('--root', '-r',
                help='Sets the fett root directory, overriding defaults and FETT_ROOT environment variable')
        subparsers = parser.add_subparsers(dest='subparser')

        parser_send = subparsers.add_parser('send', help='Tar up a layer and write it to the given file')
        parser_send.add_argument('name')
        parser_send.add_argument('filename', help='path to output file or - for stdout')

        parser_receive = subparsers.add_parser('receive', help='Read in a gzipped tar archive and create a new layer from it')
        parser_receive.add_argument('name')
        parser_receive.add_argument('filename', help='path to a the input file or - for stdin')

        parser_list = subparsers.add_parser('list', help='List available layers')
        parser_list.add_argument('-l', help='Long listing', dest='long_list', action='store_true')

        parser_destroy = subparsers.add_parser('destroy', help='Completely delete a layer. This will break any layers built on top of it.')
        parser_destroy.add_argument('name')
        parser_destroy.add_argument('--force', help='Do not prompt for confirmation', action='store_true')

        parser_exec = subparsers.add_parser('exec', help='Switch to a new fs/pid/uts namespace, chroot into the layer, and exec a command. If a name is not specified, a new layer with a random name is created.')
        parser_exec.add_argument('from_layer')
        parser_exec.add_argument('command')
        parser_exec.add_argument('--name', help='Name for the new layer', default=None)

        args = parser.parse_args()

        if args.debug:
            log.setLevel(logging.DEBUG)

        if args.root:
            self.rootdir = args.root

        fname = 'cmd_%s' % args.subparser
        func = getattr(self, fname, None)
        if not func:
            log.critical('Unknown command: %s' % args.subparser)
            return -1
        else:
            return func(args)

    def cmd_send(self, args):
        layer = Layer(self.rootdir, args.name)

        if not layer.exists():
            log.critical('%s does not exist, aborting.' % args.name)
            return -1

        mountpoint = layer.mount()
        if mountpoint is None:
            return -1

        ret = subprocess.call('tar -C %s -czpf %s .' % (mountpoint, args.filename), shell=True)
        if ret != 0:
            log.error('Unable to tar %s' % args.name)
            return -1

        return layer.unmount()

    def cmd_receive(self, args):
        layer = Layer(self.rootdir, args.name)
        if layer.exists():
            log.critical('%s already exists, aborting.' % args.name)
            return -1

        ret = layer.create()
        if ret != 0:
            return ret

        ret = subprocess.call('tar -C %s -xzpf %s .' % (layer.path, args.filename), shell=True)
        if ret != 0:
            log.error('Unable to untar from %s' % args.filename)
            return ret
        return 0

    def cmd_list(self, args):
        try:
            dirs = os.listdir(self.rootdir)
        except os.error as e:
            log.critical('Unable to list %s: %s' % (self.rootdir, str(e)))
            return -1

        ret = []

        dirs = (os.path.abspath(os.path.join(self.rootdir, x)) for x in dirs if not x.startswith('.'))
        dirs = ((x, os.stat(x)) for x in dirs if os.path.isdir(x))
        for dirpath, st in sorted(dirs, key=lambda x: x[1].st_ctime, reverse=True):
            dirname = os.path.basename(dirpath)
            if args.long_list:
                size, mtime = fsinfo(dirpath)
                if mtime != 0:
                    mtime = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(mtime))
                else:
                    mtime = '-'
                ret.append((dirname, size, mtime, dirpath))
            else:
                ret.append(dirname)
        
        if args.long_list:
            print_columns(ret, max_length=40, headers=('NAME', 'SIZE', 'MTIME', 'PATH'))
        else:
            for name in ret:
                print name
        return 0

    def cmd_destroy(self, args):
        layer = Layer(self.rootdir, args.name)
        if not layer.exists():
            log.critical('%s does not exist' % layerdir)
            return -1

        if not args.force:
            sys.stdout.write('Are you sure you want to destroy %s (yes/no)? ' % args.name)
            answer = sys.stdin.readline().rstrip('\r\n')
            if answer != 'yes':
                sys.stdout.write('No.\n')
                return -1
        return layer.destroy()


    def _child_thread(self, name, mountpoint, command):
        log.debug('Initializing child thread %s' % name)

        fett.mount('/dev', '%s/dev' % mountpoint, 'none', fett.MS_BIND, '')

        try:
            log.debug('chroot(%r)' % mountpoint)
            os.chroot(mountpoint)
            os.chdir('/')
        except os.error as e:
            log.critical('Unable to chroot to %s: %s' % (mountpoint, str(e)))
            return -1

        fett.mount('none', '/proc', 'proc', 0, '')
        fett.mount('none', '/sys', 'sysfs', 0, '')

        try:
            os.remove('/etc/mtab')
        except os.error as e:
            pass
        
        try:
            fett.sethostname(name)
        except os.error as e:
            log.critical('Unable to set hostname %s: %s' % (name, str(e)))
            return -1

        cmd = command.split(' ')
        env = {
            'TERM': 'xterm',
            'HOME': '/',
        }
        try:
            log.debug('execve(%r, %r, %r)' % (cmd[0], cmd, env))
            os.execve(cmd[0], cmd, env)
            log.error('execve returned. This should never happen')
            return -1
        except os.error as e:
            log.critical('Unable to call execve(%r, %r, %r): %s' % (cmd[0], cmd, env, str(e)))
            return -1


    def cmd_exec(self, args):
        if args.name is None:
            name = random_name()
        else:
            name = args.name

        parent_layer = Layer(self.rootdir, args.from_layer)
        if not parent_layer.exists():
            log.critical('Parent layer %s does not exist' % parent_layer.name)
            return -1

        layer = Layer(self.rootdir, name)
        if not layer.exists():
            layer.create(parent_layer)

        mountpoint = layer.mount()
        if mountpoint is None:
            log.critical('Unable to setup overlay mount')
            return -1
        
        flags = (
            #fett.CLONE_FILES |
            fett.CLONE_NEWNS |
            fett.CLONE_NEWPID |
            fett.CLONE_NEWUTS |
            fett.CLONE_NEWNET |
            fett.CLONE_VFORK |
            fett.CLONE_VM |
            fett.SIGCHLD
        )
        pid = fett.clone(self._child_thread, (name, mountpoint, args.command), flags, 65536)
        log.debug('Cloned PID %i' % pid)
        #fett.unshare(fett.CLONE_NEWNS | fett.CLONE_NEWUTS | fett.CLONE_NEWNET)
            
        #pid = os.fork()
        # parent: wait for child to exit, unmount everything
        log.debug('Forked PID %i' % pid)
        #ret = os.waitpid(pid, 0)
        #log.debug('waitpid returned %i' % ret)
        exitpid, status = os.wait()
        ret = (status >> 16)
        signal = (status & 0x00FF)
        log.debug('PID %i exited with signal=%i code=%i' % (exitpid, signal, ret))
        os.chdir('/')
        return layer.unmount()


def random_name():
    return '%04x' % random.getrandbits(16)


def fsinfo(path):
    total_bytes = 0
    last_modified = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            try:
                path = os.path.join(dirpath, filename)
                st = os.lstat(path)
                total_bytes += st.st_size
                if st.st_mtime > last_modified:
                    last_modified = st.st_mtime
            except os.error:
                pass
    return (total_bytes, last_modified)


def ensure_directory(path):
    if not os.path.exists(path):
        try:
            log.info('Creating directory %s' % path)
            os.makedirs(path)
        except os.error as e:
            log.critical('Unable to create %s: %s' % (path, str(e)))
            return -1
    return 0


def print_columns(seq, max_length=None, padding=2, headers=None):
    seq = [[str(y) for y in x] for x in seq]
    width = collections.defaultdict(int)
    for row in seq:
        for i, col in enumerate(row):
            if len(col) > width[i]:
                width[i] = len(col)

    if max_length is not None:
        for i, v in width.items():
            if v > max_length:
                width[i] = max_length

    if headers:
        seq.insert(0, headers)

    for row in seq:
        for i, col in enumerate(row):
            sys.stdout.write(col.ljust(width[i] + padding, ' '))
        sys.stdout.write('\n')


if __name__ == '__main__':
    maincmd = Fett()
    sys.exit(maincmd.main())
